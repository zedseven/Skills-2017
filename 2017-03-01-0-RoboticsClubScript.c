#pragma config(Sensor, dgtl2,  armEncoder,     sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  forwardSensor,  sensorTouch)
#pragma config(Sensor, dgtl6,  backwardSensor, sensorTouch)
#pragma config(Sensor, dgtl7,  leftSensor,     sensorTouch)
#pragma config(Sensor, dgtl8,  rightSensor,    sensorTouch)
#pragma config(Sensor, dgtl9,  pickupSensor,   sensorTouch)
#pragma config(Motor,  port1,  leftMotor,      tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port6,  clawMotor,      tmotorVex269_MC29, openLoop, reversed)
#pragma config(Motor,  port7,  armMotor,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10, rightMotor,     tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*----------------------------------------------------------------------------------------------------*\
|*                                - Clawbot Single Joystick Control -                                 *|
|*                                      ROBOTC on VEX 2.0 Cortex                                      *|
|*                                                                                                    *|
|*  This program uses a single joystick, either right or left to drive the robot. Use notes below     *|
|*  to reconfigure which joystick is used. The joystick buttons are used to raise and lower the arm.	*|
|*  The joystick buttons are used to open and close the claw.																					*|
|*																																																		*|
|*                                        ROBOT CONFIGURATION                                         *|
|*    NOTES:                                                                                          *|
|*    1)	Ch1 is the X axis and Ch2 is the Y axis for the RIGHT joystick.                             *|
|*    2)	Ch3 is the Y axis and Ch4 is the X axis for the LEFT joystick.                              *|
|*		3)	Button 5U and 5L are on the front left side of the joystick.																*|
|*		3)	Button 6U and 6L are on the front right side of the joystick.																*|
|*                                                                                                    *|
|*    MOTORS & SENSORS:                                                                               *|
|*    [I/O Port]        [Name]          [Type]                               [Description]            *|
|*    Motor - Port 2   rightMotor    VEX 393 Motor                         Right drive motor          *|
|*    Motor - Port 6   clawMotor     VEX 393 Motor w/ Motor Controller 29   Claw motor                 *|
|*    Motor - Port 7   armMotor      VEX 393 Motor w/ Motor Controller 29   Arm motor                  *|
|*    Motor - Port 10  leftMotor     VEX 393 Motor                         Left drive motor           *|
\*----------------------------------------------------------------------------------------------------*/

//+++++++++++++++++++++++++++++++++++++++++++++| MAIN |+++++++++++++++++++++++++++++++++++++++++++++++

unsigned float defaultSpeed = (50 / 2); //Default movement speed.
unsigned float fullTurnTime = 8;
bool haveFootball = false; //Variable for storing whether the football is in the robot's possession.
//bool pickingUpFootball = false; //Variable for storing whether or not the robot is trying to pick up the football.
//bool droppingFootball = false;

unsigned int prevMovements[2000]; //An array for storing every move the robot has made since start.
unsigned int pmLength = 0; //Length of prevMovements.
signed int lastDir = -1;
signed int backwardsMoveIndex = 0; //Current index for the iterations through prevMovements. Used for going backwards.

void armDrive()
{
	while(SensorValue[armEncoder] < 55)
	{
		motor[armMotor] = 27;
	}
	motor[armMotor] = 0;
}

void armPickup()
{
	while(SensorValue[armEncoder] > 0)
	{
		motor[armMotor] = -27;
	}
	motor[armMotor] = 0;
	haveFootball = true;
	backwardsMoveIndex = pmLength - 1; //prevMovements works in indexes of two - one for direction, second for duration.
}

void armDropOff()
{
	while(SensorValue[armEncoder] > -145)
	{
		motor[armMotor] = -47;
	}
	motor[armMotor] = 0;
	haveFootball = false;
}

void logMovement(signed int dir)
{
	//Store the movement in the record for reversal later.
	if(dir != lastDir)
	{
		prevMovements[pmLength] = lastDir;
		prevMovements[pmLength + 1] = time1[T1];
		lastDir = dir;
		clearTimer(T1);
		pmLength += 2;
	}
}

void stopMoving()
{
	motor[leftMotor] = 0;
	motor[rightMotor] = 0;
}

void moveDir(int dir, bool logMove = true)
{
	bool moved = true;
	switch(dir)
	{
	case 0: //Forward
		motor[leftMotor] = -defaultSpeed;
		motor[rightMotor] = -defaultSpeed;
		break;
	case 1: //Backward
		motor[leftMotor] = defaultSpeed;
		motor[rightMotor] = defaultSpeed;
		break;
	case 2: //Left
		motor[leftMotor] = -defaultSpeed;
		motor[rightMotor] = defaultSpeed;
		break;
	case 3: //Right
		motor[leftMotor] = defaultSpeed;
		motor[rightMotor] = -defaultSpeed;
		break;
	default:
		moved = false;
		stopMoving();
	}
	if(moved == true)
	{
		if(logMove == true)
		{
			logMovement(dir);
		}
	}
}

task main()
{
	SensorValue[armEncoder] = 0; //Set the relative default. This uses the starting position of the arm, so we need to be sure the arm is properly aligned for the start.
	armDrive();
	clearTimer(T1);
	while(true)
	{
		if(haveFootball == true)
		{
			//if(droppingFootball == false)
			//{
			if(backwardsMoveIndex >= 0)
			{
				//Follow the path taken, but backwards. This should take the robot right up to the blue line.
				signed int dir = prevMovements[backwardsMoveIndex];
				signed int oppositeDir;
				switch(dir)
				{
				case 0: //Forward
					oppositeDir = 1; //Backward
					break;
				case 1: //Backward
					oppositeDir = 0; //Forward
					break;
				case 2: //Left
					oppositeDir = 3; //Right
					break;
				case 3: //Right
					oppositeDir = 2; //Left
					break;
				}
				clearTimer(T1);
				while(time1[T1] < prevMovements[backwardsMoveIndex + 1])
				{
					moveDir(oppositeDir, false);
				}
				backwardsMoveIndex -= 2;
				if(backwardsMoveIndex < 0)
				{
					backwardsMoveIndex = 0;
					pmLength = 0;
					//prevMovements = ;
				}
			}
			else
			{
				//Drop the football
				armDropOff();
			}
			//}
			/*else
			{
			if()
			{

			}
			}*/
		}
		else
		{
			/*if(pickingUpFootball == true)
			{
			if(SensorValue(footballSensor) == 1) //might have to invert this later
			{
			haveFootball = true;
			pickingUpFootball = false;
			}
			else
			{
			//PICK UP FOOTBALL (Run motors for pickup arm, then return them to normal afterwards - maybe a continuous action)
			}
			}
			else
			{*/
			if(SensorValue(pickupSensor) == 0)
			{
				//Pick up the football
				armPickup();
			}
			else if(SensorValue(forwardSensor) == 0)
			{
				moveDir(0, true);
			}
			else if(SensorValue(backwardSensor) == 0)
			{
				moveDir(1, true);
			}
			else if(SensorValue(rightSensor) == 0)
			{
				moveDir(3, true);
			}
			else if(SensorValue(leftSensor) == 0)
			{
				moveDir(2, true);
			}
			else
			{
				stopMoving();
				logMovement(-1);
			}

			//pivot right - test for later
			//motor[leftMotor] = defaultSpeed;
			//motor[rightMotor] = -defaultSpeed;
			//}
		}
	}
}
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
